没问题。针对**“手机号+验证码（自动注册/登录）”**且支持**未来扩展（微信/Github）**的需求，我为您整理了一份独立的模块开发文档。

您可以直接把这份文档丢给后端和前端开发人员，照着做就能实现一套专业的、可扩展的认证系统。

---

# 独立模块文档：用户注册与登录系统 (Auth System)

## 1. 核心设计原则
1.  **无密码 (Passwordless)**：仅使用手机号+验证码，降低用户记忆负担。
2.  **自动注册 (Auto-Register)**：新手机号首次登录即视为注册，无需单独流程。
3.  **结构分离 (Decoupled)**：用户身份(`users`)与认证方式(`user_auths`)物理分离，为未来接入微信/GitHub 扫清障碍。

---

## 2. 数据库设计 (Database Schema)
请在数据库中创建以下两张表。

### 2.1 用户基础表 (`users`)
只存“人”的信息，不存账号密码。

```sql
CREATE TABLE `users` (
  `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '用户唯一ID',
  `nickname` VARCHAR(64) DEFAULT NULL COMMENT '昵称 (注册时为空，完善资料后填入)',
  `avatar` VARCHAR(255) DEFAULT NULL COMMENT '头像URL',
  `created_at` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '注册时间',
  `updated_at` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户基础信息表';
```

### 2.2 用户授权表 (`user_auths`) —— **核心表**
存所有的登录“钥匙”。

```sql
CREATE TABLE `user_auths` (
  `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
  `user_id` BIGINT UNSIGNED NOT NULL COMMENT '关联 users.id',
  `identity_type` VARCHAR(20) NOT NULL COMMENT '登录类型: phone, wechat, github',
  `identifier` VARCHAR(64) NOT NULL COMMENT '标识: 手机号, OpenID, UserID',
  `credential` VARCHAR(255) DEFAULT NULL COMMENT '凭证: 密码Hash (手机登录此项为空)',
  `last_login_at` DATETIME DEFAULT NULL COMMENT '最后登录时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_auth` (`identity_type`, `identifier`), -- 确保同一个手机号只能绑定一次
  INDEX `idx_user_id` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户授权方式表';
```

---

## 3. API 接口定义 (API Endpoints)

需要两个核心接口。

### 3.1 发送验证码
*   **URL**: `POST /api/auth/send-code`
*   **功能**: 发送 6 位短信验证码，并存入缓存（Redis）。
*   **请求参数**:
    ```json
    { "phone": "13800138000" }
    ```
*   **后端逻辑**:
    1.  校验手机号格式。
    2.  **防刷检查**: 检查该手机号 60秒内是否已发过。
    3.  生成 `123456` (随机)。
    4.  存入 Redis: Key=`sms:13800138000`, Value=`123456`, Expire=`300s` (5分钟)。
    5.  调用短信平台接口发送。

### 3.2 登录/注册校验
*   **URL**: `POST /api/auth/login`
*   **功能**: 校验验证码，返回 Token。
*   **请求参数**:
    ```json
    {
      "phone": "13800138000",
      "code": "123456"
    }
    ```
*   **返回成功 (200 OK)**:
    ```json
    {
      "code": 200,
      "msg": "success",
      "data": {
        "token": "eyJhbGciOiJIUzI1Ni...",  // JWT Token
        "is_new_user": true               // true=去填资料, false=进首页
      }
    }
    ```

---

## 4. 后端核心业务逻辑 (伪代码)

这是**最关键**的部分，处理了“自动注册”和“数据分离”的逻辑。

```python
def login_with_phone(phone, code):
    # 1. 校验验证码 (从Redis取)
    cached_code = redis.get(f"sms:{phone}")
    if not cached_code or cached_code != code:
        return Error("验证码无效或已过期")

    # 2. 查询该手机号是否已存在于 user_auths 表
    auth_record = db.query(
        "SELECT * FROM user_auths WHERE identity_type='phone' AND identifier=?", 
        phone
    )

    user_id = 0
    is_new_user = False

    # 3. 分支处理：老用户 vs 新用户
    if auth_record:
        # === A. 老用户 ===
        user_id = auth_record.user_id
        # 更新最后登录时间
        db.execute("UPDATE user_auths SET last_login_at=NOW() WHERE id=?", auth_record.id)
        is_new_user = False
    else:
        # === B. 新用户 (自动注册) ===
        # B1. 开启数据库事务
        db.begin_transaction()
        try:
            # B2. 先在 users 表创建一个空的“人”
            user_id = db.execute("INSERT INTO users (created_at) VALUES (NOW())")
            
            # B3. 再在 user_auths 表把手机号绑上去
            db.execute(
                "INSERT INTO user_auths (user_id, identity_type, identifier) VALUES (?, 'phone', ?)",
                user_id, phone
            )
            db.commit()
            is_new_user = True
        except:
            db.rollback()
            return Error("注册失败")

    # 4. 生成 Token (使用 user_id)
    token = generate_jwt_token(user_id)

    # 5. 销毁验证码 (防止重复使用)
    redis.delete(f"sms:{phone}")

    return {
        "token": token,
        "is_new_user": is_new_user
    }
```

---

## 5. 前端交互细节 (H5)

### 5.1 验证码倒计时逻辑
*   用户点击“获取验证码”后，前端必须立即禁用按钮，并显示 `60s` 倒计时。
*   哪怕用户刷新页面，倒计时状态最好也能通过 `localStorage` 保持（优化体验，非必须）。

### 5.2 登录后的跳转路由
前端拿到后端返回的 JSON 后，根据 `is_new_user` 字段决定去向：

```javascript
// 前端伪代码
axios.post('/api/auth/login', { phone, code }).then(res => {
    const { token, is_new_user } = res.data.data;
    
    // 1. 存 Token
    localStorage.setItem('auth_token', token);

    // 2. 路由跳转
    if (is_new_user) {
        // 新人 -> 强制去完善资料页 (上传头像/昵称)
        window.location.href = '/profile/edit?mode=onboarding';
    } else {
        // 老人 -> 直接去首页
        window.location.href = '/home';
    }
});
```

---

## 6. 安全与风控 (Security Checklist)

为了防止短信接口被恶意刷爆（这会浪费你的钱），请务必告知后端加上以下限制：

1.  **频率限制 (Rate Limiting)**：
    *   **限制手机号**：同一个手机号，1分钟只能发1条，1小时只能发5条，24小时只能发10条。
    *   **限制IP**：同一个IP地址，24小时内只能请求 20 次接口。
2.  **验证码复杂度**：6位数字即可，不要太简单（如111111），也不要太复杂（不要字母）。
3.  **Token 安全**：Token 有效期建议设置 **30天**，减少用户重复登录的麻烦。